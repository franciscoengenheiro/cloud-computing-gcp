\chapter{Operations}\label{ch:operations}

This chapter presents the operations implemented in the VisionFlow system.
The service operations were divided into two categories, each represented by a grpc protobuf contract~\cite{grpc-protobuf}, with the following features:

\begin{itemize}
    \item \textbf{Functional Operations}: operations that are part of the main functionality of the system (e.g., uploading images, retrieving processed information);
    \item \textbf{Elasticity Management}: operations that allow the system to scale up or down the available resources (i.e., the number of instances of the gRPC server and the image processing application).
\end{itemize}

All messages in contract are prefixed with \texttt{Request} or \texttt{Response}
to indicate the direction of the message in order to improve the readability of the contract.


\section{Functional Operations}\label{sec:functional_operations}

The primary functionalities of the VisionFlow system are the submission (upload) and retrieval of image data;
and the processing of images to extract relevant information.
These functionalities are implemented in the functional operations contract.

\subsection{Contract}\label{subsec:functional-operations-contract}

The functional service contract has the following RPC~\cite{rpc-protocol} operations:

\begin{itemize}
    \item \textbf{uploadImage}: Adds a file with an image.
    The image is sent in chunks, and the operation returns an image identifier.
    \item \textbf{downloadImage}: With the image identifier created after the upload,
    this operation downloads a previously uploaded image file;
    \item \textbf{getImageCharacteristics}: Uses the image identifier to retrieve an image's processing data.
    \item \textbf{getFileNamesByCharacteristic}:
    Returns stored file names depending on a date range and particular picture characteristic
    (e.g., images that contain cats in the last week).
\end{itemize}

The following messages are used in the contract:

\begin{itemize}
    \item \textbf{UploadImageRequest}:
    Contains the chunk of data of the image (which represents portions of the image), its name, the content type (for download visualization), and translation language (for image labels translation);
    \item \textbf{UploadImageResponse}:
    Contains the image identifier generated after the image is uploaded, which is used to identify the image in the system;
    \item \textbf{DownloadImageRequest}:
    Contains the image identifier and the path where the image will be saved in the client's system;
    \item \textbf{DownloadImageResponse}:
    Contains the name, complete data in bytes, and content type of the image;
    \item \textbf{GetImageCharacteristicsRequest}:
    Contains the image identifier;
    \item \textbf{GetImageCharacteristicsResponse}:
    Contains the list of labels found in the image, the translations corresponding to the characteristics, and the date the image was processed;
    \item \textbf{GetFileNamesRequest}:
    Contains the start date, end date, and characteristic to search for;
    \item \textbf{GetFileNamesResponse}:
    Contains the list of file names found based on the image processing characteristics query.
\end{itemize}

\subsection{Design Aspects}\label{subsec:functional-operations-design-aspects}

On the upload operation, instead of the server receiving the entire image at once, the image is sent in parts, which are then processed by the server.
By preventing the complete image from being stored at once,
sending data in chunks enables effective memory utilization in the server
(i.e., if n clients are uploading images simultaneously with y MB of data, the server will not need to store all the data at once - n x y in the worst-case scenario).
On error, the server deletes the image data that was already stored, ensuring that the system is not overloaded with unnecessary data.

To let the client choose the translation language, a translation language field was added to the correspondent message.
An improvement we had in mind but did not implement was to allow the client to process the image in multiple languages simultaneously.

The upload operation returns an image identifier, which is used to refer to the image in the system.
The identifier is generated by the server and sent back to the client after the image is successfully uploaded.
It is composed of the image name and a random UUID~\cite{oracle-uuid} (e.g., cat\#abcd-6708300c-230e-4076-84cd-bfc20b512732).
This identifier can be used to download the image, retrieve its characteristics,
and query for other images with similar characteristics.
The separation of the image name and the UUID is necessary in the download operation to allow the client to save the image with the original name.


\section{Elasticity Management}\label{sec:elasticity_management}

Elasticity management is a key aspect of cloud computing.
It allows the system to adapt to the workload by scaling up or down the resources, depending on the demand.
This is important to ensure that the system is able to handle the workload efficiently and cost-effectively.

For this project,
elasticity management was implemented as a mandatory requirement for scaling instances of both the gRPC server and the image processing application
(\textit{labelsApp}), granting the clients the ability to request the scaling of these services.

\subsection{Contract}\label{subsec:elasticity-management-contract}

The elasticity management service contract has the following RPC operations:

\begin{itemize}
    \item \textbf{listManagedInstanceGroups}: lists all managed instance groups.
    For this operation,
    the client does not need to provide any additional information
    and the server will return a stream of \texttt{ManagedInstanceGroupResponse} messages.
    This information can be used to identify the instance groups that can be managed for scaling and listing VMs;
    \item \textbf{resizeManagedInstanceGroup}: resizes a managed instance group.
    The client must provide the name of the managed instance group and the new size;
    \item \textbf{listManagedInstanceGroupVMs}: lists all VMs in a managed instance group.
    The client must provide the name of the managed instance group, and the server will return a stream of \texttt{ManagedInstanceGroupVMResponse} messages.
\end{itemize}

The following messages are used in the contract:

\begin{itemize}
    \item \textbf{ManagedInstanceGroupRequest} and \texttt{ManagedInstanceGroupResponse}:
    contains the \textbf{name} of a managed instance group.
    Even though both messages represent the same information, they are used in different contexts,
    and as such, they were defined as separate messages to increase the readability of the contract;
    \item \textbf{ManagedInstanceGroupResizeRequest}:
    contains the \textbf{name} of a managed instance group and the \textbf{new size} for the group;
    \item \textbf{ManagedInstanceGroupVMResponse}: contains the \textbf{name} and \textbf{status} (e.g., RUNNING, TERMINATED) of a VM instance.
\end{itemize}

\subsection{Design Aspects}\label{subsec:elasticity-management-design-aspects}

The grpc contract for the elasticity management service was designed
to allow for instance management and listing without depending on a specific instance group.

The client can request the list of managed instance groups and then request additional operations such as resizing or listing VMs in a specific instance group.
This way, the contract won't need to be altered if more or less instance groups are added to the system in the future.

However, the server implementation will need to be updated to handle the new instance groups,
as that information is stored locally.
In a real-world scenario, this information should be stored in a database or a cloud service, as the server can also be managed by the elasticity management service,
which would lead to inconsistencies across the system.
Additionally, there's no dynamic update support for the instance groups available if stored locally.

In the contract, the decision to stream the responses made by the server in the listing operations,
was made to allow the potential clients to process the information as it arrives,
instead of waiting for the entire response to be sent by the server.
